#ZSS language: https://github.com/Windblade-GR01/Ikemen-GO/wiki/ZSS
#ZSS syntax highlighter for Notepad++: https://github.com/K4thos/npp_zss
#-------------------------------------------------------------------------------
#Commenting in ZSS
#You may notice that the ";" character is now replaced with the "#" character.
#This is because ";" is now used to separate parameters in sctrls rather than a
#blank space.

#===============================================================================
# Functions
#===============================================================================
#Used to avoid repeating change state code to reference returning to state 0 or
#11 if crouching. $type is used to specify if it's standing or crouching.
#1 - crouching
#0 - standing
[Function EndState(type)]
if animTime = 0 {
	changeState{value: 11 * $type; ctrl: roundState > 1}
}

[Function AttackLevel0()]
mapSet{map: "attackDamage"; value: 40} #Damage on hit
mapset{map: "chipDamage"; value: 3}	#Damage on block
mapSet{map: "hitStop"; value: 6} #Amount of hitstop frames for both players
mapSet{map: "hitPriority"; value: 1} #If this value is higher than the opponents, then it will beat them out
mapSet{map: "hitStunAmount"; value: 14} #Amount of time spent in hitstun
mapSet{map: "hitFlags"; value: 0} #0 = MAF, 1 = HAF (Whiffs on crouchers), 2 = LAF (Whiffs on standing), 3 = AF (Air only), 4 = MAFD (Hits all for supers), 5 = D (Only hits hard knockdown)
mapSet{map: "guardFlags"; value: 0} #0 = MA (Blocked by everything), 1= M (Block all ground, hit in air), 2 = L (Block Low), 3 = H (Block High), 4 = HA (Block high and air for air attacks)
mapSet{map: "untechTime"; value: 14} #Amount of time before you can tech in the air
mapSet{map: "blockStunAmount"; value: 11} #amount of blockstun
mapSet{map: "hitSparkNum"; value: 0} #What hit spark to use
mapSet{map: "sparkPosX"; value: -10} #The X position
mapSet{map: "sparkPosY"; value: -76} #Y Position
mapSet{map: "attackSoundGroup"; value: 5}  #Sound on hit
mapSet{map: "attackSoundIndex"; value: 0} 
mapSet{map: "guardSoundGroup"; value: 6} #Sound on block
mapSet{map: "guardSoundIndex"; value: 0} 
mapSet{map: "groundPushbackX"; value: -4} #Velocity applied to enemy on ground hit
mapSet{map: "groundPushbackY"; value: 0}
mapSet{map: "hitSlideTime"; value: 5} #how much time the enemy slides back after getting hit
mapSet{map: "airPushbackX"; value: -1.4} #Velocity applied to enemy on air hit
mapSet{map: "airPushbackY"; value: -3}
mapSet{map: "groundGuardPushbackX"; value: -4} #Block pushback
mapSet{map: "guardSlideTime"; value: 5} #how much time the enemy slides back after blocking
mapSet{map: "airGuardPushbackX"; value: -1.9} #Air block pushback
mapSet{map: "airGuardPushbackY"; value: -0.8}
mapSet{map: "hardKnockDown"; value: 0}	#If opponent goes into hard knockdown
mapSet{map: "hardKnockDownRecover"; value: 0}
mapSet{map: "Gravity"; value: .35}	#Gravity value set on hit
mapSet{map: "AttackKill"; value: 1} #Does the attack kill or not
mapSet{map: "GuardKill"; value: 1}	#Does chip damage kill
mapSet{map: "animationType"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "animationTypeAir"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "groundType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "airType"; value: 0} #0 = High, 1 = Low, 2 = Trip

[Function AttackLevel1()]
mapSet{map: "attackDamage"; value: 50} #Damage on hit
mapset{map: "chipDamage"; value: 4}	#Damage on block
mapSet{map: "hitStop"; value: 8} #Amount of hitstop frames for both players
mapSet{map: "hitPriority"; value: 1} #If this value is higher than the opponents, then it will beat them out
mapSet{map: "hitStunAmount"; value: 16} #Amount of time spent in hitstun
mapSet{map: "hitFlags"; value: 0} #0 = MAF, 1 = HAF (Whiffs on crouchers), 2 = LAF (Whiffs on standing), 3 = AF (Air only), 4 = MAFD (Hits all for supers), 5 = D (Only hits hard knockdown)
mapSet{map: "guardFlags"; value: 0} #0 = MA (Blocked by everything), 1= M (Block all ground, hit in air), 2 = L (Block Low), 3 = H (Block High), 4 = HA (Block high and air for air attacks)
mapSet{map: "untechTime"; value: 16} #Amount of time before you can tech in the air
mapSet{map: "blockStunAmount"; value: 11} #amount of blockstun
mapSet{map: "hitSparkNum"; value: 0} #What hit spark to use
mapSet{map: "sparkPosX"; value: -10} #The X position
mapSet{map: "sparkPosY"; value: -76} #Y Position
mapSet{map: "attackSoundGroup"; value: 5}  #Sound on hit
mapSet{map: "attackSoundIndex"; value: 1} 
mapSet{map: "guardSoundGroup"; value: 6} #Sound on block
mapSet{map: "guardSoundIndex"; value: 0} 
mapSet{map: "groundPushbackX"; value: -4} #Velocity applied to enemy on ground hit
mapSet{map: "groundPushbackY"; value: 0}
mapSet{map: "hitSlideTime"; value: 5} #how much time the enemy slides back after getting hit
mapSet{map: "airPushbackX"; value: -1.4} #Velocity applied to enemy on air hit
mapSet{map: "airPushbackY"; value: -3}
mapSet{map: "groundGuardPushbackX"; value: -4} #Block pushback
mapSet{map: "guardSlideTime"; value: 5} #how much time the enemy slides back after blocking
mapSet{map: "airGuardPushbackX"; value: -1.9} #Air block pushback
mapSet{map: "airGuardPushbackY"; value: -0.8}
mapSet{map: "hardKnockDown"; value: 0}	#If opponent goes into hard knockdown
mapSet{map: "hardKnockDownRecover"; value: 0}
mapSet{map: "Gravity"; value: .35}	#Gravity value set on hit
mapSet{map: "AttackKill"; value: 1} #Does the attack kill or not
mapSet{map: "GuardKill"; value: 1}	#Does chip damage kill
mapSet{map: "animationType"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "animationTypeAir"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "groundType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "airType"; value: 0} #0 = High, 1 = Low, 2 = Trip

[Function AttackLevel2()]
mapSet{map: "attackDamage"; value: 60} #Damage on hit
mapset{map: "chipDamage"; value: 4}	#Damage on block
mapSet{map: "hitStop"; value: 11} #Amount of hitstop frames for both players
mapSet{map: "hitPriority"; value: 1} #If this value is higher than the opponents, then it will beat them out
mapSet{map: "hitStunAmount"; value: 18} #Amount of time spent in hitstun
mapSet{map: "hitFlags"; value: 0} #0 = MAF, 1 = HAF (Whiffs on crouchers), 2 = LAF (Whiffs on standing), 3 = AF (Air only), 4 = MAFD (Hits all for supers), 5 = D (Only hits hard knockdown)
mapSet{map: "guardFlags"; value: 0} #0 = MA (Blocked by everything), 1= M (Block all ground, hit in air), 2 = L (Block Low), 3 = H (Block High), 4 = HA (Block high and air for air attacks)
mapSet{map: "untechTime"; value: 18} #Amount of time before you can tech in the air
mapSet{map: "blockStunAmount"; value: 15} #amount of blockstun
mapSet{map: "hitSparkNum"; value: 0} #What hit spark to use
mapSet{map: "sparkPosX"; value: -10} #The X position
mapSet{map: "sparkPosY"; value: -76} #Y Position
mapSet{map: "attackSoundGroup"; value: 5}  #Sound on hit
mapSet{map: "attackSoundIndex"; value: 2} 
mapSet{map: "guardSoundGroup"; value: 6} #Sound on block
mapSet{map: "guardSoundIndex"; value: 1} 
mapSet{map: "groundPushbackX"; value: -4} #Velocity applied to enemy on ground hit
mapSet{map: "groundPushbackY"; value: 0}
mapSet{map: "hitSlideTime"; value: 5} #how much time the enemy slides back after getting hit
mapSet{map: "airPushbackX"; value: -1.4} #Velocity applied to enemy on air hit
mapSet{map: "airPushbackY"; value: -3}
mapSet{map: "groundGuardPushbackX"; value: -4} #Block pushback
mapSet{map: "guardSlideTime"; value: 5} #how much time the enemy slides back after blocking
mapSet{map: "airGuardPushbackX"; value: -1.9} #Air block pushback
mapSet{map: "airGuardPushbackY"; value: -0.8}
mapSet{map: "hardKnockDown"; value: 0}	#If opponent goes into hard knockdown
mapSet{map: "hardKnockDownRecover"; value: 0}
mapSet{map: "Gravity"; value: .35}	#Gravity value set on hit
mapSet{map: "AttackKill"; value: 1} #Does the attack kill or not
mapSet{map: "GuardKill"; value: 1}	#Does chip damage kill
mapSet{map: "animationType"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "animationTypeAir"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "groundType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "airType"; value: 0} #0 = High, 1 = Low, 2 = Trip

[Function AttackLevel3()]
mapSet{map: "attackDamage"; value: 70} #Damage on hit
mapset{map: "chipDamage"; value: 5}	#Damage on block
mapSet{map: "hitStop"; value: 14} #Amount of hitstop frames for both players
mapSet{map: "hitPriority"; value: 1} #If this value is higher than the opponents, then it will beat them out
mapSet{map: "hitStunAmount"; value: 20} #Amount of time spent in hitstun
mapSet{map: "hitFlags"; value: 0} #0 = MAF, 1 = HAF (Whiffs on crouchers), 2 = LAF (Whiffs on standing), 3 = AF (Air only), 4 = MAFD (Hits all for supers), 5 = D (Only hits hard knockdown)
mapSet{map: "guardFlags"; value: 0} #0 = MA (Blocked by everything), 1= M (Block all ground, hit in air), 2 = L (Block Low), 3 = H (Block High), 4 = HA (Block high and air for air attacks)
mapSet{map: "untechTime"; value: 20} #Amount of time before you can tech in the air
mapSet{map: "blockStunAmount"; value: 15} #amount of blockstun
mapSet{map: "hitSparkNum"; value: 0} #What hit spark to use
mapSet{map: "sparkPosX"; value: -10} #The X position
mapSet{map: "sparkPosY"; value: -76} #Y Position
mapSet{map: "attackSoundGroup"; value: 5}  #Sound on hit
mapSet{map: "attackSoundIndex"; value: 2} 
mapSet{map: "guardSoundGroup"; value: 6} #Sound on block
mapSet{map: "guardSoundIndex"; value: 3} 
mapSet{map: "groundPushbackX"; value: -4} #Velocity applied to enemy on ground hit
mapSet{map: "groundPushbackY"; value: 0}
mapSet{map: "hitSlideTime"; value: 5} #how much time the enemy slides back after getting hit
mapSet{map: "airPushbackX"; value: -1.4} #Velocity applied to enemy on air hit
mapSet{map: "airPushbackY"; value: -3}
mapSet{map: "groundGuardPushbackX"; value: -4} #Block pushback
mapSet{map: "guardSlideTime"; value: 5} #how much time the enemy slides back after blocking
mapSet{map: "airGuardPushbackX"; value: -1.9} #Air block pushback
mapSet{map: "airGuardPushbackY"; value: -0.8}
mapSet{map: "hardKnockDown"; value: 0}	#If opponent goes into hard knockdown
mapSet{map: "hardKnockDownRecover"; value: 0}
mapSet{map: "Gravity"; value: .35}	#Gravity value set on hit
mapSet{map: "AttackKill"; value: 1} #Does the attack kill or not
mapSet{map: "GuardKill"; value: 1}	#Does chip damage kill
mapSet{map: "animationType"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "animationTypeAir"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "groundType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "airType"; value: 0} #0 = High, 1 = Low, 2 = Trip

[Function AttackLevel4()]
mapSet{map: "attackDamage"; value: 80} #Damage on hit
mapset{map: "chipDamage"; value: 6}	#Damage on block
mapSet{map: "hitStop"; value: 16} #Amount of hitstop frames for both players
mapSet{map: "hitPriority"; value: 1} #If this value is higher than the opponents, then it will beat them out
mapSet{map: "hitStunAmount"; value: 22} #Amount of time spent in hitstun
mapSet{map: "hitFlags"; value: 0} #0 = MAF, 1 = HAF (Whiffs on crouchers), 2 = LAF (Whiffs on standing), 3 = AF (Air only), 4 = MAFD (Hits all for supers), 5 = D (Only hits hard knockdown)
mapSet{map: "guardFlags"; value: 0} #0 = MA (Blocked by everything), 1= M (Block all ground, hit in air), 2 = L (Block Low), 3 = H (Block High), 4 = HA (Block high and air for air attacks)
mapSet{map: "untechTime"; value: 22} #Amount of time before you can tech in the air
mapSet{map: "blockStunAmount"; value: 15} #amount of blockstun
mapSet{map: "hitSparkNum"; value: 0} #What hit spark to use
mapSet{map: "sparkPosX"; value: -10} #The X position
mapSet{map: "sparkPosY"; value: -76} #Y Position
mapSet{map: "attackSoundGroup"; value: 5}  #Sound on hit
mapSet{map: "attackSoundIndex"; value: 4} 
mapSet{map: "guardSoundGroup"; value: 6} #Sound on block
mapSet{map: "guardSoundIndex"; value: 2} 
mapSet{map: "groundPushbackX"; value: -4} #Velocity applied to enemy on ground hit
mapSet{map: "groundPushbackY"; value: 0}
mapSet{map: "hitSlideTime"; value: 5} #how much time the enemy slides back after getting hit
mapSet{map: "airPushbackX"; value: -1.4} #Velocity applied to enemy on air hit
mapSet{map: "airPushbackY"; value: -3}
mapSet{map: "groundGuardPushbackX"; value: -4} #Block pushback
mapSet{map: "guardSlideTime"; value: 5} #how much time the enemy slides back after blocking
mapSet{map: "airGuardPushbackX"; value: -1.9} #Air block pushback
mapSet{map: "airGuardPushbackY"; value: -0.8}
mapSet{map: "hardKnockDown"; value: 0}	#If opponent goes into hard knockdown
mapSet{map: "hardKnockDownRecover"; value: 0}
mapSet{map: "Gravity"; value: .35}	#Gravity value set on hit
mapSet{map: "AttackKill"; value: 1} #Does the attack kill or not
mapSet{map: "GuardKill"; value: 1}	#Does chip damage kill
mapSet{map: "animationType"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "animationTypeAir"; value: 0} #0 = light, 1 = medium, 2 = hard, 3 = back, 4 = up, 5 = diagup
mapSet{map: "groundType"; value: 0} #0 = High, 1 = Low, 2 = Trip
mapSet{map: "airType"; value: 0} #0 = High, 1 = Low, 2 = Trip

[Function enableJumpCancel()]
IgnoreHitPause{
if moveContact && command = "holdup"  { 
	if (stateType != A ){
		changeState{value: 40}
	}
	
	#if (Map(CDU) || command = "holdup" && Map(h_a)) && stateType != A {
	#changeState{value: 6100}
	#}

	if (statetype = A && map(jumpCount) > 0) {
	changeState{value: 46}
	}
}
}

[Function Attack_5A_Init()]
call AttackLevel1();
mapAdd{map:"attack5AChainAmount"; value: -1;}
mapSet{map:"enableSpecialCancels"; value: 1}


[Function Attack_2A_Init()]
call AttackLevel1();
mapAdd{map:"attack2AChainAmount"; value: -1;}
mapSet{map:"enableSpecialCancels"; value: 1}


[Function Attack_5B_Init()]
call AttackLevel2();
mapAdd{map:"attack5BChainAmount"; value: -1;}
mapSet{map:"enableSpecialCancels"; value: 1}


[Function Attack_2B_Init()]
call AttackLevel2();
mapAdd{map:"attack2BChainAmount"; value: -1;}
mapSet{map:"enableSpecialCancels"; value: 1}


[Function Attack_5C_Init()]
call AttackLevel3();
mapAdd{map:"attack5CChainAmount"; value: -1;}
mapSet{map:"enableSpecialCancels"; value: 1}


[Function Attack_2C_Init()]
call AttackLevel3();
mapset{map: "hardKnockDown"; value: 1}
mapAdd{map:"attack2CChainAmount"; value: -1;}
mapSet{map:"enableSpecialCancels"; value: 1}


[Function Attack_j5A_Init()]
call AttackLevel1();

[Function Attack_j5B_Init()]
call AttackLevel2();

[Function Attack_j5C_Init()]
call AttackLevel3();

[Function ResetChain()]
mapSet{map:"attack5AChainAmount"; value: 2;}
mapSet{map:"attack2AChainAmount"; value: 2;}
mapSet{map:"attack5BChainAmount"; value: 1;}
mapSet{map:"attack2BChainAmount"; value: 1;}
mapSet{map:"attack5CChainAmount"; value: 1;}
mapSet{map:"attack2CChainAmount"; value: 1;}

[Function InitRoundStart()]
mapset{map:"standAvailable"; value: 1}
mapset{map:"standActive"; value: 0}
mapSet{map:"maxAirJumps"; value: 1}
mapSet{map:"airJumpCount"; value: map(maxAirJumps)}

[Function InitSpecialMove()]
mapSet{map:"enableSpecialCancels"; value: 0}

#-------------------------------------------------------------------------------
#Used to call system sounds from the screenpack
[Function SysSnd(b, s, c)]
playSnd{value: F $b, $s; channel: $c}

#-------------------------------------------------------------------------------
#Used to call sounds coming from this character
[Function CSnd(bank, sound, c)]
playSnd{value: S $bank, $sound; channel: $c}

#-------------------------------------------------------------------------------
#Used to apply palFx during EX moves
[Function EXFX(time)]
palFx{time: $time; add: 32, 16, 0; sinadd: 64, 32, 5, 3}

#===============================================================================
# Lose by Time Over
#===============================================================================
# ZSS difficulty: basic
#This is how statedefs are defined in ZSS. It must always end with a ";" or it
#will result in a crash. 
[StateDef 170;
type: S; movetype: I; physics: S;
anim: 170; ctrl: 0; velset: 0, 0;
sprpriority: 1;]

#If you used a trigger that normally read "trigger1 = 1" you can just declare
#the sctrl with no condition like below.
notHitBy{value: SCA; time: 1}

#===============================================================================
# Win state decider
#===============================================================================
# ZSS difficulty: basic
[StateDef 180;
type: S; movetype: I; physics: S;
anim: -2; ctrl: 0; velset: 0, 0;
sprpriority: 1;]

changeState{value: 181; ctrl: 0}

#===============================================================================
# win pose 1 - Bow
#===============================================================================
# ZSS difficulty: basic
[StateDef 181;
type: S; movetype: I; physics: S;
anim: 181; ctrl: 0; velset: 0, 0;
sprpriority: 1;]

#trigger is replaced with a simple "if". All conditions can be handled the same
#with multiple if blocks. Optional Assert roundnotover
if animTime < -2 {
	assertSpecial{flag: roundnotover}
}

notHitBy{value: SCA; time: 1}

#===============================================================================
# Introduction
#===============================================================================
# ZSS difficulty: basic
[StateDef 191;
type: S; movetype: I; physics: S;
anim: 190; ctrl: 0; velset: 0, 0;
sprpriority: 1;]

if roundState = 0 {
	changeAnim{value: 190}
}

assertSpecial{flag: intro}

persistent(0) if roundState != 0 {
	explod{
		anim: 191;
		postype: p1;
		pos: 260, -90;
		velocity: -4.2, -7;
		accel: 0, .32;
		removetime: 48;
	}
}

if animElemTime(7) = 1 {
	explod{
		anim: 192;
		postype: p1;
		pos: 60, -70;
		velocity: 2, -4;
		accel: 0, .32;
		removetime: 35;
	}
}

if animElem = 7 {
	call SysSnd(5, 2, 1);
}

if animElemTime(7) = 3 {
	call SysSnd(5, 3, 2);
}

#Change to stand state when done
call EndState(0);

#-------------------------------------------------------------------------------
[StateDef 195;
type: S; movetype: I; physics: S;
anim: 195; ctrl: 0; velset: 0, 0;
sprpriority: 2;]

if time = 40 {
	ctrlSet{value: 1}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# 5A
#===============================================================================
# ZSS difficulty: easy
[StateDef 200;
type: S;                             
movetype: A;                         
physics: S;                           
juggle: 1;                                                   
ctrl: 0;                              
anim: 200;                            
poweradd: 10;                         
sprpriority: 2;]   

if time = 0{
		call Attack_5A_Init();
}            

call enableJumpCancel();       

if animElem = 3 { 
hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

if time = 1 {
	call CSnd(0, 0, 1);
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# 5A Dash
#===============================================================================
# ZSS difficulty: easy
[StateDef 201;
type: S;                             
movetype: A;                         
physics: S;                           
juggle: 1;                                                   
ctrl: 0;                              
anim: 200;                            
poweradd: 10;                         
sprpriority: 2;]   

if time = 0{
		call Attack_5A_Init();
		velSet{x: 12}
}            

call enableJumpCancel();       

if animElem = 3 { 
hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

if time = 1 {
	call CSnd(0, 0, 1);
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# 5B
#===============================================================================
[StateDef 210;
type: S; movetype: A; physics: S;
juggle: 4; poweradd: 30; ctrl: 0;
 anim: 210;
sprpriority: -1;]

if animElemTime(2) >= 0 && animElemTime(7) < 0 {
	width{value: 15, 0}
}

if time = 0{
	call Attack_5B_Init();
}
call enableJumpCancel();  
if time = 2 {
	call CSnd(0, 4, 1);
}

if time > 0{
if enemy, map(counterHit) = 1{
		mapset{map:"attackDamage"; value: 70;}
		mapset{map:"hitStop"; value: 20;}
		mapset{map:"hitStunAmount"; value: 25;}
	}
	else{
	call Attack_5B_Init();
	}
}

if animElem = 3 {
hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

if animElem = 5 {
	sprPriority{value: 2}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# 5B Dash
#===============================================================================
[StateDef 211;
type: S; movetype: A; physics: S;
juggle: 4; poweradd: 30; ctrl: 0;
 anim: 210;
sprpriority: -1;]

if animElemTime(2) >= 0 && animElemTime(7) < 0 {
	width{value: 15, 0}
}

if time = 0{
	call Attack_5B_Init();
	velSet{x: 12}
}
call enableJumpCancel();  
if time = 2 {
	#It is worth mentioning that if you want to use the rest of the parameters
	#a playSnd uses, you can use it just the same as below:
	# Playsnd{value: S0, 4; channel: 1}
	call CSnd(0, 4, 1);
}

if animElem = 3 {
hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

if animElem = 5 {
	sprPriority{value: 2}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# 6B
#===============================================================================
[StateDef 220;
type: S; movetype: A; physics: S;
juggle: 4; poweradd: 30; ctrl: 0;
anim: 230;
sprpriority: -1;]

if animElemTime(2) >= 0 && animElemTime(7) < 0 {
	width{value: 15, 0}
}

if time = 0{
call Attack_5B_Init();
velSet{x: 8}
}

call enableJumpCancel();  

if time = 2 {
	#It is worth mentioning that if you want to use the rest of the parameters
	#a playSnd uses, you can use it just the same as below:
	# Playsnd{value: S0, 4; channel: 1}
	call CSnd(0, 4, 1);
}

if animElem = 3 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Medium;             
		guardflag: L;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: Low;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

if animElem = 5 {
	sprPriority{value: 2}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# 5C
#===============================================================================
# ZSS difficulty: easy
[StateDef 230;
type: S; movetype: A; physics: S;
juggle: 4; poweradd: 11; ctrl: 0; anim: 220;
sprpriority: 2;]

if time = 0{
call Attack_5C_Init();
removeExplod{}
Explod{anim: 10220; pos: 0, 0; postype: P1; ownpal: 1; bindtime: -1; sprpriority: 3; scale: const(size.xscale),const(size.yscale); pausemovetime: 0; supermovetime: 0}
mapSet{map:"hitStop"; value: 6}
mapSet{map:"attackDamage"; value: 30}
mapSet{map: "attackSoundIndex"; value: 2}
mapSet{map:"counterHit"; value: 1}
}

call enableJumpCancel();  

if time = 2 {
	call CSnd(0, 0, 1);
}

if animElem = 4 {
	Explod{anim: 17110; pos: 0, 0; postype: P1; ownpal: 1; bindtime: -1; sprpriority: 3; scale: const(size.xscale),const(size.yscale); pausemovetime: 0; supermovetime: 0}
	
}

if animElem = 6{
mapSet{map:"hitStop"; value: 14}
mapSet{map:"attackDamage"; value: 40}
mapSet{map: "attackSoundIndex"; value: 4}
}

if animElem = 3 || animElem = 6 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Hard;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

if time = 29{
	mapSet{map:"counterHit"; value: 0}
	ctrlSet{value: 1}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# 5C Dash
#===============================================================================
# ZSS difficulty: easy
[StateDef 231;
type: S; movetype: A; physics: S;
juggle: 4; poweradd: 11; ctrl: 0; anim: 221;
sprpriority: 2;]

if time = 0{
call Attack_5C_Init();
mapSet{map:"hitStunAmount"; value: 32}
mapSet{map: "attackSoundIndex"; value: 4}
velSet{x: 15}
removeExplod{}
Explod{anim: 10221; pos: 0, 0; postype: P1; ownpal: 1; bindtime: -1; sprpriority: 3; scale: const(size.xscale),const(size.yscale); supermovetime: 0}
}

call enableJumpCancel();  

if time = 2 {
	call CSnd(0, 0, 1);
}

if animElem = 3 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Hard;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

if time = 27 {
	ctrlSet{value: 1}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# Stand On
#===============================================================================
[StateDef 830;
type: S; movetype: I; physics: S;
juggle: 5; poweradd: 30; ctrl: 0;
anim: 830;
sprpriority: 2;]


if time = 0{
		mapSet{map: "standActive"; value: 1}
		Helper{
		ID: 10820;
		pos: 40;
		postype: p1;
		stateNo: 10820;
		helpertype: normal;
		name: "StarPlatinum";
		keyctrl: 1;
		ownpal: 1;
		}
}

if time = 1{
ctrlSet{value: 1}
}


#Change to stand state when done
call EndState(0);

#===============================================================================
# Stand Off
#===============================================================================
[StateDef 831;
type: S; movetype: I; physics: S;
juggle: 5; poweradd: 30; ctrl: 0;
anim: 830;
sprpriority: 2;]


if time = 0{
		mapSet{map: "standActive"; value: 0}
}

if time = 1{
ctrlSet{value: 1}
}

#Change to stand state when done
call EndState(0);

#===============================================================================
# Stand On Air
#===============================================================================
[StateDef 832;
type: A; movetype: I; physics: A;
juggle: 5; poweradd: 30; ctrl: 0;
sprpriority: 2;]


if time = 0{
		mapSet{map: "standActive"; value: 1}
		Helper{
		ID: 10820;
		pos: 140;
		postype: back;
		stateNo: 10825;
		helpertype: normal;
		name: "StarPlatinum";
		keyctrl: 1;
		ownpal: 1;
		}
}

if time = 1{
ctrlSet{value: 1}
}

#===============================================================================
# Stand Off Air
#===============================================================================
[StateDef 833;
type: A; movetype: I; physics: A;
juggle: 5; poweradd: 30; ctrl: 0;
sprpriority: 2;]


if time = 0{
		mapSet{map: "standActive"; value: 0}
}

if time = 1{
ctrlSet{value: 1}
}


#===============================================================================
# 2A
#===============================================================================
[StateDef 400;
type: C; movetype: A; physics: C;
juggle: 5; poweradd: 8; ctrl: 0;
anim: 400; sprpriority: 2;]

if time = 0{
call Attack_2A_Init();
}

call enableJumpCancel();  

if time = 1 {
	call CSnd(0, 0, 1);
}

if animElem = 2 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: L;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

if animElem = 9{
	ctrlSet{value: 1}
}

#Change to stand state when done
call EndState(1);

#===============================================================================
# 2A Dash
#===============================================================================
[StateDef 401;
type: C; movetype: A; physics: C;
juggle: 5; poweradd: 8; ctrl: 0;
anim: 401; sprpriority: 2;]

if time = 0{
call Attack_2A_Init();
velSet{x: 9}
}

call enableJumpCancel();  

if time = 1 {
	call CSnd(0, 0, 1);
}

if animElem = 3 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: L;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

#Change to stand state when done
call EndState(1);

#===============================================================================
# 2B
#===============================================================================
[StateDef 410;
type: C; movetype: A; physics: C;
juggle: 6; poweradd: 25; ctrl: 0;
anim: 410; sprpriority: 2;]

if time = 0{
call Attack_2B_Init();
removeExplod{}
Explod{anim: 10410; pos: 0, 0; postype: P1; ownpal: 1; bindtime: -1; sprpriority: 3; scale: const(size.xscale),const(size.yscale); supermovetime: 0}
}

call enableJumpCancel();  

if time = 1 {
	call CSnd(0, 1, 1);
}

#This is the first hit, triggered on the 3rd element of animation.
if time = 0 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}


#Change to stand state when done
call EndState(1);

#===============================================================================
# 2B Dash
#===============================================================================
[StateDef 411;
type: C; movetype: A; physics: C;
juggle: 6; poweradd: 25; ctrl: 0;
anim: 410; sprpriority: 2;]

if time = 0{
call Attack_2B_Init();
velSet{x: 10}
removeExplod{}
Explod{anim: 10410; pos: 0, 0; postype: P1; ownpal: 1; bindtime: -1; sprpriority: 3; scale: const(size.xscale),const(size.yscale); supermovetime: 0}
}

call enableJumpCancel();  

if time = 1 {
	call CSnd(0, 1, 1);
}

#This is the first hit, triggered on the 3rd element of animation.
if time = 0 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}


#Change to stand state when done
call EndState(1);

#===============================================================================
# 2C
#===============================================================================
# ZSS difficulty: easy
[StateDef 430;
type: C; movetype: A; physics: C;
juggle: 5; poweradd: 11; ctrl: 0;
anim: 420; sprpriority: 2;]

if time = 0{
call Attack_2C_Init();
removeExplod{}
Explod{anim: 10420; pos: 0, 0; postype: P1; ownpal: 1; bindtime: -1; sprpriority: 3; scale: const(size.xscale),const(size.yscale); pausemovetime: 999999}
}

call enableJumpCancel();  

if time = 1 {
	call CSnd(0, 0, 1);
}

if animElem = 3 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: L;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: Trip;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

#Change to stand state when done
call EndState(1);

#===============================================================================
# 2C Dash
#===============================================================================
# ZSS difficulty: easy
[StateDef 431;
type: C; movetype: A; physics: C;
juggle: 5; poweradd: 11; ctrl: 0;
anim: 421; sprpriority: 2;]

if time = 0{
call Attack_2C_Init();
velSet{x: 13}
removeExplod{}
Explod{anim: 10421; pos: 0, 0; postype: P1; ownpal: 1; bindtime: -1; sprpriority: 3; scale: const(size.xscale),const(size.yscale); supermovetime: 0}
}

call enableJumpCancel();  

if time = 1 {
	call CSnd(0, 0, 1);
}

if animElem = 3 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: L;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: Trip;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

#Change to stand state when done
call EndState(1);

#===============================================================================
# 2S
#===============================================================================
[StateDef 440;
type: C; movetype: A; physics: C;
juggle: 7; poweradd: 35; ctrl: 0;
anim: 440; sprpriority: 2;]

if time = 1 {
	call CSnd(0, 2, 1);
}


#Change to stand state when done
call EndState(1);

#===============================================================================
# j5A
#===============================================================================
# ZSS difficulty: easy
[StateDef 600;
type: A; movetype: A; physics: A;
juggle: 2; poweradd: 5; ctrl: 0;
anim: 600; sprpriority: 2;]

if time = 0{
call Attack_j5A_Init();
}

if time = 1 {
	call CSnd(0, 0, 1);
}

if animElem = 2 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: HA;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

#This gives control back to kfm early. While this could be done better in a
#number of ways, this is a 1:1 creation of kfm from elecbyte so this change is
#left intact.
if animElemTime(3) = 2 {
	ctrlSet{value: 1}
}

#===============================================================================
# j5B
#===============================================================================
# ZSS difficulty: easy
[StateDef 610;
type: A; movetype: A; physics: A;
juggle: 4; poweradd: 30; ctrl: 0;
anim: 610; sprpriority: 2;]

if time = 0{
call Attack_j5B_Init();
}

if time = 2 {
	call CSnd(0, 1, 1);
}

if animElem = 3 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: HA;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

#===============================================================================
# j5B
#===============================================================================
# ZSS difficulty: easy
[StateDef 710;
type: A; movetype: A; physics: A;
juggle: 4; poweradd: 30; ctrl: 0;
anim: 610; sprpriority: 2;]

if time = 0{
call Attack_j5B_Init();
}

if animElem = 3 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: HA;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

#===============================================================================
# j5C
#===============================================================================
# ZSS difficulty: easy
[StateDef 630;
type: A; movetype: A; physics: A;
juggle: 3; poweradd: 10; ctrl: 0;
anim: 620; sprpriority: 2;]

if time = 0{
call Attack_j5C_Init();
}

if time = 1 {
	call CSnd(0, 0, 1);
}

if animElem = 2 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: HA;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

#===============================================================================
# j5S
#===============================================================================
# ZSS difficulty: easy
[StateDef 640;
type: A; movetype: A; physics: A;
juggle: 4; poweradd: 30; ctrl: 0;
anim: 640; sprpriority: 2;]

if time = 2 {
	call CSnd(0, 1, 1);
}

if animElem = 2 {
	hitDef{
		attr: S, NA;                 
		damage: map(attackDamage), map(chipDamage);                
		animtype: Light;             
		guardflag: M;        
		hitflag: MAF;             
		priority: map(hitPriority), Hit;                     
		pausetime: map(hitStop), map(hitStop);             
		sparkno: map(hitSparkNum);                   
		sparkxy: map(sparkPosX), map(sparkPosY);                                           
		hitsound: map(attackSoundGroup), map(attackSoundIndex);               
		guardsound: map(guardSoundGroup), map(guardSoundIndex);             
		ground.type: High;                   
		ground.hittime: map(hitStunAmount);  
		air.hittime: map(untechTime); 
		guard.hittime: map(blockStunAmount);
		ground.velocity: map(groundPushbackX), map(groundPushbackY); 
		ground.slidetime: map(hitSlideTime);
		air.velocity: map(airPushbackX), map(airPushbackY);  
		guard.velocity: map(groundGuardPushbackX);
		guard.slidetime: map(guardSlideTime);
		airguard.velocity: map(airGuardPushbackX), map(airGuardPushbackY); 
		air.type: High;  
		yaccel: map(Gravity);
		fall: map(hardKnockDown);
		fall.recover: map(hardKnockDownRecover);
		kill: map(AttackKill);
		guard.kill: map(GuardKill);
	}
}

#===============================================================================
# Stand Off Ora Ora (236 A)
#===============================================================================
[StateDef 11001;
type: S; movetype: A; physics: S; ctrl: 0;
anim: 21050;
sprpriority: 0;]

if time = 0 {
Helper{
		ID: 10820;
		pos: 40;
		postype: p1;
		stateNo: 11000;
		helpertype: normal;
		name: "StarPlatinum";
		keyctrl: 1;
		ownpal: 1;
		}
}

if animTime = 0{
changeState{value: 0; ctrl: 1;}
}

#===============================================================================
# Override common states (use same number to override):
#===============================================================================


#===============================================================================
# States that are always executed (use StateDef -2)
#===============================================================================
[StateDef -2]
IgnoreHitPause{
DisplayToClipboard{
text: "enableSpecialCancels = %f"; params: map(enableSpecialCancels)
}
}

#===============================================================================
# States that are executed when in self's state file (use StateDef -3)
#===============================================================================
[StateDef -3]
#displayToClipboard{text: "p1cp: %f p2cp: %f"; params: p2BodyDist X,map(jug)}

#Landing Sound
#This controller plays a sound every time KFM lands from a jump, or back-dash.
#The code below is another way to represent the structure of
#triggerall, trigger1, trigger2
if time = 1 && (stateNo = 52 || stateNo = 106) { #Jump land || Run-back land
	call CSnd(40, 0, 1);
}
